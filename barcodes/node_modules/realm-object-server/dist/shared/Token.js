"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const crypto = require("crypto");
const moment = require("moment");
function isAdminToken(token) {
    if (!token) {
        return false;
    }
    if ('isAdmin' in token) {
        return token['isAdmin'];
    }
    if ('isAdminToken' in token) {
        return token['isAdminToken']();
    }
    return false;
}
exports.isAdminToken = isAdminToken;
class Token {
    static parse(tokenString, publicKey, throwIfExpiredToken = true) {
        if (!tokenString || tokenString === "") {
            throw new Error("The tokenString parameter was not provided or is blank");
        }
        const parts = tokenString.split(':');
        if (parts.length !== 2) {
            throw new Error("The tokenString parameter does not have 2 parts separated by a colon (':')");
        }
        const tokenBase64 = parts[0];
        const dataBuffer = Buffer.from(tokenBase64, 'base64');
        const signatureBase64 = parts[1];
        const verify = crypto.createVerify("RSA-SHA256");
        const signatureBuffer = Buffer.from(signatureBase64, 'base64');
        verify.update(dataBuffer);
        if (!verify.verify(publicKey, signatureBuffer)) {
            throw new Error("The token data could not be verified against its signature");
        }
        const tokenData = JSON.parse(dataBuffer.toString());
        if (tokenData.expires) {
            const expiresAt = moment.unix(tokenData.expires);
            if (expiresAt.isBefore(moment()) && throwIfExpiredToken) {
                throw new Error("The token has expired");
            }
        }
        const common = {
            identity: tokenData.identity,
            appId: tokenData.app_id,
            expires: tokenData.expires,
            access: tokenData.access || [],
            salt: tokenData.salt,
            canSkipRevocationCheck: tokenData.canSkipRevocationCheck || false,
        };
        if (common.access.indexOf("refresh") >= 0) {
            return new RefreshToken(Object.assign(common, {
                isAdmin: (tokenData.is_admin === true),
                isEmailConfirmed: (tokenData.isEmailConfirmed === true)
            }));
        }
        return new AccessToken(Object.assign(common, {
            path: tokenData.path,
            syncLabel: tokenData.sync_label,
        }));
    }
    constructor(params) {
        this.identity = params.identity;
        this.appId = params.appId;
        this.expires = params.expires;
        this.salt = params.salt || crypto.randomBytes(4).toString('hex');
        this.canSkipRevocationCheck = params.canSkipRevocationCheck;
    }
    toJSON() {
        const json = {
            app_id: this.appId,
            identity: this.identity,
            access: this.access,
            salt: this.salt,
        };
        if (this.expires) {
            json.expires = this.expires;
        }
        if (this.canSkipRevocationCheck) {
            json.canSkipRevocationCheck = this.canSkipRevocationCheck;
        }
        return json;
    }
    data() {
        return JSON.stringify(this.toJSON());
    }
    encodedData() {
        return new Buffer(this.data()).toString("base64");
    }
    sign(privateKey) {
        const sign = crypto.createSign("RSA-SHA256");
        sign.update(this.data());
        const signatureBase64 = sign.sign(privateKey).toString("base64");
        return `${this.encodedData()}:${signatureBase64}`;
    }
}
exports.Token = Token;
class UserToken extends Token {
    constructor(params) {
        super(params);
        this.isAdmin = params.isAdmin;
    }
    toJSON() {
        return Object.assign(super.toJSON(), {
            is_admin: this.isAdmin,
        });
    }
}
exports.UserToken = UserToken;
class RefreshToken extends Token {
    constructor(params) {
        super(params);
        this.access = ["refresh"];
        this.isAdmin = params.isAdmin;
        this.isEmailConfirmed = params.isEmailConfirmed || false;
    }
    toJSON() {
        return Object.assign(super.toJSON(), {
            is_admin: this.isAdmin,
            isEmailConfirmed: this.isEmailConfirmed
        });
    }
}
exports.RefreshToken = RefreshToken;
class AccessToken extends Token {
    constructor(params) {
        super(params);
        this.access = params.access;
        this.path = params.path;
        this.syncLabel = params.syncLabel;
    }
    toJSON() {
        return Object.assign(super.toJSON(), {
            path: this.path,
            sync_label: this.syncLabel,
        });
    }
    isAdminToken() {
        if (!this.path && this.identity === '__admin') {
            return true;
        }
        return false;
    }
}
exports.AccessToken = AccessToken;
function generateAdminToken({ privateKey, expires, access = ['download', 'upload', 'manage'], appId = 'io.realm.auth', canSkipRevocationCheck = false, }) {
    const accessToken = new AccessToken({
        identity: '__admin',
        appId: appId,
        access: access,
        expires: expires,
        canSkipRevocationCheck,
    });
    return accessToken.sign(privateKey);
}
exports.generateAdminToken = generateAdminToken;
//# sourceMappingURL=Token.js.map