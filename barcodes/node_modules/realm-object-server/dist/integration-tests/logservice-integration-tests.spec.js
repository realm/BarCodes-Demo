"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const TestServer_1 = require("../TestServer");
const Token_1 = require("../shared/Token");
const chai_1 = require("chai");
const WebSocket = require("uws");
const superagent = require("superagent");
const invalidKey = `-----BEGIN PRIVATE KEY-----
MIIBVAIBADANBgkqhkiG9w0BAQEFAASCAT4wggE6AgEAAkEAzx8FGksrmjHgwU2G
3XiJsr428sBUFlPrjB3iO7C+OvZ7DX1ued0gNMGl039JGy/Jz8jBKxyxRIRXwowr
cHa45QIDAQABAkA+rsqijIFjpxi4J7hbKnGx8LM8gExyfW9Z9mlTW0gXG5mR54ta
Zp9pRS8DRnrm9tq56cVAxUPQrVFcEGv1pXK5AiEA+NrB1aKj2zKfBmdZHhWaDZIP
5w3UOlW8N1izeHLl/m8CIQDVEX7XAI16ZMOLkLwEfQE62aI/3gFxJq5JO9kp3UDn
6wIgPKrQAG4C9kgz/pKpZi0r/kzydYioiYQnO3LzZdTU/x8CICvYM8+ub26WOZ8I
o4gQ6SXhDwAxgP51xTuQszloLCkNAiEA6M0dbOsKy5cAEIoH7sO1E8q0MpPyws+V
q2kDYzZ7tX0=
-----END PRIVATE KEY-----`;
const expectNoMessages = (client) => {
    client.on('message', e => {
        throw new Error(`Received an unexpected message: ${e}`);
    });
};
describe('LogService Integration Tests', function () {
    let server;
    let client;
    before(() => __awaiter(this, void 0, void 0, function* () {
        server = new TestServer_1.TestServer();
        yield server.start();
        client = new WebSocket(`ws://${server.address}/log/debug`);
    }));
    after(() => __awaiter(this, void 0, void 0, function* () {
        if (server) {
            yield server.shutdown();
        }
    }));
    afterEach(() => {
        if (client) {
            client.close();
            client = undefined;
        }
    });
    describe('establishing connections', () => {
        beforeEach(() => {
            client = new WebSocket(`ws://${server.address}/log/debug`);
        });
        it('should be able to connect to a websocket', (done) => {
            expectNoMessages(client);
            client = new WebSocket(`ws://${server.address}/log/debug`);
            client.on('open', () => {
                done();
            });
            client.on('error', err => {
                done(err);
            });
        });
        it('should timeout if no message is sent', (done) => {
            expectNoMessages(client);
            client.on('close', (code, message) => {
                chai_1.assert.equal(code, 1008, 'Unexpected close code');
                chai_1.assert.equal(message, 'Operation failed to complete within 1000ms');
                done();
            });
        });
        it('should close if message is malformed', (done) => {
            expectNoMessages(client);
            client.on('open', () => {
                client.send('hi there!');
            });
            client.on('close', (code, message) => {
                chai_1.assert.equal(code, 1008, 'Unexpected close code');
                chai_1.assert.equal(message, 'Expected a serialized JSON object as the first message');
                done();
            });
        });
        it('should close if message is missing action', (done) => {
            expectNoMessages(client);
            client.on('open', () => {
                client.send('{}');
            });
            client.on('close', (code, message) => {
                chai_1.assert.equal(code, 1008, 'Unexpected close code');
                chai_1.assert.equal(message, "Your request did not validate because of missing parameters. 'action': Missing parameter 'action'!");
                done();
            });
        });
        it('should close if message has wrong action', (done) => {
            expectNoMessages(client);
            client.on('open', () => {
                client.send('{"action": "..."}');
            });
            client.on('close', (code, message) => {
                chai_1.assert.equal(code, 1008, 'Unexpected close code');
                chai_1.assert.equal(message, 'Expected an authentication message: { action: "authenticate", ... }');
                done();
            });
        });
        it('should close if message is missing token', (done) => {
            expectNoMessages(client);
            client.on('open', () => {
                client.send('{"action": "authenticate"}');
            });
            client.on('close', (code, message) => {
                chai_1.assert.equal(code, 1008, 'Unexpected close code');
                chai_1.assert.equal(message, "Your request did not validate because of missing parameters. 'token': Missing parameter 'token'!");
                done();
            });
        });
        it('should close if token is not parsing', (done) => {
            expectNoMessages(client);
            client.on('open', () => {
                client.send('{"action": "authenticate", "token": "..."}');
            });
            client.on('close', (code, message) => {
                chai_1.assert.equal(code, 1008, 'Unexpected close code');
                chai_1.assert.equal(message, "The tokenString parameter does not have 2 parts separated by a colon (':')");
                done();
            });
        });
        it('should receive messages with admin access token', (done) => {
            let log;
            const token = server.adminToken;
            client.on('open', () => {
                client.send(JSON.stringify({
                    action: "authenticate",
                    token
                }));
            });
            client.on('message', msg => {
                log = JSON.parse(msg);
                client.close();
            });
            client.on('close', (code, message) => {
                chai_1.assert.equal(code, 0, 'Unexpected close code');
                chai_1.assert.equal(message, "");
                chai_1.assert(Array.isArray(log), "Expected an array of log entries");
                chai_1.assert(log.length > 0, "Expected log entries");
                done();
            });
        });
        it('should receive messages with admin refresh token', (done) => {
            let log;
            const token = new Token_1.RefreshToken({
                appId: 'io.realm.testing',
                identity: 'someone',
                isAdmin: true,
            });
            const signedToken = token.sign(server.privateKey);
            client.on('open', () => {
                client.send(JSON.stringify({
                    action: "authenticate",
                    token: signedToken
                }));
            });
            client.on('message', msg => {
                log = JSON.parse(msg);
                client.close();
            });
            client.on('close', (code, message) => {
                chai_1.assert.equal(message, "");
                chai_1.assert.equal(code, 0, "Unexpected close code");
                chai_1.assert(Array.isArray(log), "Expected an array of log entries");
                chai_1.assert(log.length > 0, "Expected log entries");
                done();
            });
        });
        it('should fail on an invalidly signed refresh token', (done) => {
            expectNoMessages(client);
            const token = new Token_1.RefreshToken({
                appId: 'io.realm.testing',
                identity: 'someone',
                isAdmin: true,
            });
            const signedToken = token.sign(invalidKey);
            client.on('error', (err) => {
                done(err);
            });
            client.on('open', () => {
                client.send(JSON.stringify({
                    action: "authenticate",
                    token: signedToken
                }));
            });
            client.on('close', (code, message) => {
                chai_1.assert.equal(code, 1008, 'Unexpected close code');
                chai_1.assert.equal(message, 'The token data could not be verified against its signature');
                done();
            });
        });
        it('should fail on a revoked token', () => __awaiter(this, void 0, void 0, function* () {
            expectNoMessages(client);
            const now = Math.floor(Date.now() / 1000);
            const token = new Token_1.RefreshToken({
                appId: 'io.realm.testing',
                identity: 'someone',
                isAdmin: true,
                expires: now + 60
            });
            const signedToken = token.sign(server.privateKey);
            client.on('open', () => {
                client.send(JSON.stringify({
                    action: "authenticate",
                    token: signedToken
                }));
            });
            yield chai_1.assert.isFulfilled(superagent.post(`${server.url}/auth/revoke`).set({
                Authorization: signedToken,
            }).send({
                token: signedToken,
            }));
            return new Promise((resolve, reject) => {
                client.on('error', (err) => {
                    reject(err);
                });
                client.on('close', (code, message) => {
                    chai_1.assert.equal(code, 1008, 'Unexpected close code');
                    chai_1.assert.equal(message, 'The token has been revoked');
                    resolve();
                });
            });
        }));
    });
});
//# sourceMappingURL=logservice-integration-tests.spec.js.map