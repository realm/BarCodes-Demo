"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const chai_1 = require("chai");
const logger = require("./index");
const path = require("path");
const fs = require("fs-extra");
class MockLogger extends logger.Logger {
    constructor() {
        super();
    }
    log(level, msg, ctx) {
        this.logged = { level, msg, ctx };
    }
    whatWasLogged() {
        return this.logged;
    }
}
describe('Contextual logger', function () {
    it('combines inline and internal contexts', function () {
        const l = new MockLogger();
        const cl = l.withContext({ hello: 'world' });
        cl.info('something', { inline: 'context' });
        const actualEntry = l.whatWasLogged();
        chai_1.assert.deepEqual(actualEntry.ctx, { hello: 'world', inline: 'context' });
    });
    it('chains properly', function () {
        const l = new MockLogger();
        const ccl = l.withContext({ hello: 'world' }).withContext({ goodbye: 'galaxy' });
        ccl.info('something', { inline: 'context' });
        const actualEntry = l.whatWasLogged();
        chai_1.assert.deepEqual(actualEntry.ctx, { hello: 'world', goodbye: 'galaxy', inline: 'context' });
    });
    it('obscures attached context with inline context', function () {
        const l = new MockLogger();
        const ccl = l.withContext({ hello: 'world' }).withContext({ goodbye: 'galaxy' });
        ccl.info('something', { goodbye: 'inline-galaxy' });
        const actualEntry = l.whatWasLogged();
        chai_1.assert.deepEqual(actualEntry.ctx, { hello: 'world', goodbye: 'inline-galaxy' });
    });
    it('emits message events', function () {
        const l = new MockLogger();
        const cl = l.withContext({ hello: 'world' });
        let emitted = null;
        cl.once('message', (level, msg, ctx) => {
            emitted = { level, msg, ctx };
        });
        cl.info('something', { inline: 'context' });
        chai_1.assert.deepEqual(emitted, {
            level: 'info',
            msg: 'something',
            ctx: {
                hello: 'world',
                inline: 'context',
            },
        });
        cl.close();
    });
});
function fileExists(filename) {
    return __awaiter(this, void 0, void 0, function* () {
        while (true) {
            try {
                yield fs.readFile(filename);
            }
            catch (e) {
                if (e.code === 'ENOENT') {
                    continue;
                }
            }
            break;
        }
    });
}
describe('File logger', function () {
    const tmpFile = path.join(__dirname, './tmp.log');
    let log;
    beforeEach(() => {
        log = new logger.FileLogger(tmpFile);
    });
    afterEach(() => __awaiter(this, void 0, void 0, function* () {
        log.close();
        yield fs.remove(tmpFile);
    }));
    it('should write to file and reopen on sighup', function () {
        return __awaiter(this, void 0, void 0, function* () {
            log.error('hello');
            let content;
            yield fileExists(tmpFile);
            content = (yield fs.readFile(tmpFile)).toString();
            chai_1.assert.include(content, 'error: hello');
            chai_1.assert.notInclude(content, 'error: world');
            yield fs.remove(tmpFile);
            process.kill(process.pid, 'SIGHUP');
            yield fileExists(tmpFile);
            log.error('world');
            content = (yield fs.readFile(tmpFile)).toString();
            chai_1.assert.notInclude(content, 'error: hello');
            chai_1.assert.include(content, 'error: world');
        });
    });
});
describe('WinstonLogger', function () {
    it('enqueues message events until a listener is added', function () {
        const l = new logger.WinstonLogger();
        const emitted = [];
        l.info('something');
        l.debug('something else', { service: 'myservice' });
        l.on('message', (level, msg, ctx) => {
            emitted.push({ level, msg, ctx });
        });
        chai_1.assert.deepEqual(emitted, [
            { level: 'info', msg: 'something', ctx: {} },
            { level: 'debug', msg: 'something else', ctx: { service: 'myservice' } },
        ]);
        l.close();
    });
    it('reports that messages have been skipped if the buffer is small', function () {
        const l = new logger.WinstonLogger('info', 1);
        const emitted = [];
        l.info('something');
        l.error('something');
        l.debug('something else', { service: 'myservice' });
        l.on('message', (level, msg, ctx) => {
            emitted.push({ level, msg, ctx });
        });
        chai_1.assert.deepEqual(emitted, [
            { level: 'warn', msg: 'Skipped 2 early log messages', ctx: {} },
            { level: 'debug', msg: 'something else', ctx: { service: 'myservice' } },
        ]);
        l.close();
    });
});
describe('ThrowingLogger', () => {
    const l = new logger.ThrowingLogger();
    it('throws only if a fatal, error or warning is logged', () => __awaiter(this, void 0, void 0, function* () {
        chai_1.expect(() => {
            l.info('An expected info message');
        }).to.not.throw();
        chai_1.expect(() => {
            l.warn('An expected warning message');
        }).to.throw('An expected warning message');
        chai_1.expect(() => {
            l.error('An expected error message');
        }).to.throw('An expected error message');
        chai_1.expect(() => {
            l.fatal('An expected fatal message');
        }).to.throw('An expected fatal message');
    }));
});
//# sourceMappingURL=Logger.spec.js.map